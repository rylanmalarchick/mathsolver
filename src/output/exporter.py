"""
Export functionality for MathSolver solutions.

Supports exporting solutions to:
- PDF with rendered equations
- Python/SymPy code
- LaTeX document
- Plain text
"""

import os
import subprocess
import tempfile
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, List

import sympy as sp

from ..models import Solution, SolutionStep
from ..utils.errors import ExportError


@dataclass
class ExportOptions:
    """Options for export operations."""

    include_steps: bool = True
    include_timestamp: bool = True
    include_method: bool = True
    title: Optional[str] = None
    author: Optional[str] = None


class SolutionExporter:
    """
    Export solutions to various formats.

    Usage:
        exporter = SolutionExporter(solution)
        exporter.to_latex("solution.tex")
        exporter.to_pdf("solution.pdf")
        exporter.to_python("solution.py")
    """

    def __init__(self, solution: Solution, options: Optional[ExportOptions] = None):
        """
        Initialize exporter with a solution.

        Args:
            solution: The Solution object to export
            options: Export options (defaults used if not specified)
        """
        self.solution = solution
        self.options = options or ExportOptions()

    def to_python(self, output_path: Optional[str] = None) -> str:
        """
        Export solution as Python/SymPy code.

        Args:
            output_path: If provided, write to this file

        Returns:
            The generated Python code as a string
        """
        lines = [
            '"""',
            f"Solution generated by MathSolver",
        ]

        if self.options.include_timestamp:
            lines.append(f"Generated: {datetime.now().isoformat()}")

        lines.extend(
            [
                "",
                f"Original equation: {self.solution.equation.raw_latex}",
                f"Solving for: {self.solution.target_variable}",
                '"""',
                "",
                "from sympy import *",
                "",
                "# Define symbols",
            ]
        )

        # Extract all symbols
        all_symbols = set()
        if self.solution.equation.sympy_expr is not None:
            all_symbols.update(self.solution.equation.sympy_expr.free_symbols)
        if self.solution.symbolic_result is not None:
            if hasattr(self.solution.symbolic_result, "free_symbols"):
                all_symbols.update(self.solution.symbolic_result.free_symbols)

        if all_symbols:
            symbol_names = ", ".join(sorted(str(s) for s in all_symbols))
            lines.append(f'{symbol_names} = symbols("{symbol_names}")')

        lines.append("")

        # Original equation
        lines.append("# Original equation")
        lines.append(f"equation = {repr(self.solution.equation.sympy_expr)}")
        lines.append("")

        # Solution steps (as comments)
        if self.options.include_steps and self.solution.steps:
            lines.append("# Solution steps:")
            for step in self.solution.steps:
                lines.append(f"# {step.step_number}. {step.operation}")
                lines.append(f"#    {step.latex_repr}")
            lines.append("")

        # Final result
        lines.append("# Solution")
        if self.solution.target_variable:
            lines.append(f"# {self.solution.target_variable} = ")
        lines.append(f"solution = {repr(self.solution.symbolic_result)}")

        # Numerical evaluation if available
        if self.solution.numerical_result is not None:
            lines.append("")
            lines.append("# Numerical result")
            lines.append(f"numerical_value = {self.solution.numerical_result}")

        lines.append("")
        lines.append("# Verify")
        lines.append('print(f"Solution: {solution}")')
        lines.append('print(f"LaTeX: {latex(solution)}")')

        code = "\n".join(lines)

        if output_path:
            Path(output_path).write_text(code)

        return code

    def to_latex(self, output_path: Optional[str] = None) -> str:
        """
        Export solution as a LaTeX document.

        Args:
            output_path: If provided, write to this file

        Returns:
            The generated LaTeX document as a string
        """
        title = self.options.title or "MathSolver Solution"
        author = self.options.author or ""

        lines = [
            r"\documentclass[11pt]{article}",
            r"\usepackage{amsmath,amssymb}",
            r"\usepackage[margin=1in]{geometry}",
            "",
            r"\title{" + self._latex_escape(title) + "}",
        ]

        if author:
            lines.append(r"\author{" + self._latex_escape(author) + "}")

        if self.options.include_timestamp:
            date_str = datetime.now().strftime("%B %d, %Y")
            lines.append(r"\date{" + date_str + "}")
        else:
            lines.append(r"\date{}")

        lines.extend(
            [
                "",
                r"\begin{document}",
                r"\maketitle",
                "",
                r"\section*{Problem}",
                "",
                r"\begin{equation}",
                f"  {self.solution.equation.raw_latex}",
                r"\end{equation}",
                "",
            ]
        )

        # Target variable
        if self.solution.target_variable:
            lines.append(
                f"Solve for $\\displaystyle {sp.latex(self.solution.target_variable)}$."
            )
            lines.append("")

        # Solution steps
        if self.options.include_steps and self.solution.steps:
            lines.extend(
                [
                    r"\section*{Solution}",
                    "",
                ]
            )

            for step in self.solution.steps:
                lines.append(
                    f"\\textbf{{Step {step.step_number}}}: {self._latex_escape(step.operation)}"
                )
                lines.append(r"\begin{equation}")
                lines.append(f"  {step.latex_repr}")
                lines.append(r"\end{equation}")
                lines.append("")

        # Final result
        lines.extend(
            [
                r"\section*{Result}",
                "",
                r"\begin{equation}",
                r"\boxed{" + self.solution.latex + "}",
                r"\end{equation}",
                "",
            ]
        )

        # Numerical result
        if self.solution.numerical_result is not None:
            lines.append(f"Numerical value: ${self.solution.numerical_result}$")
            lines.append("")

        # Method used
        if self.options.include_method and self.solution.method_used:
            lines.append(r"\vspace{1em}")
            lines.append(
                f"\\textit{{Method: {self._latex_escape(self.solution.method_used)}}}"
            )
            lines.append("")

        lines.extend(
            [
                r"\end{document}",
                "",
            ]
        )

        latex_doc = "\n".join(lines)

        if output_path:
            Path(output_path).write_text(latex_doc)

        return latex_doc

    def to_pdf(self, output_path: str) -> str:
        """
        Export solution as a PDF document.

        Requires pdflatex to be installed on the system.

        Args:
            output_path: Path to write the PDF file

        Returns:
            Path to the generated PDF file

        Raises:
            ExportError: If PDF generation fails
        """
        # Check for pdflatex
        if not self._command_available("pdflatex"):
            raise ExportError(
                "pdflatex not found",
                suggestions=[
                    "Install TeX Live: sudo apt install texlive-latex-base",
                    "Or use LaTeX export and compile manually",
                ],
            )

        # Generate LaTeX document
        latex_content = self.to_latex()

        # Create temporary directory for compilation
        with tempfile.TemporaryDirectory() as tmpdir:
            tex_path = os.path.join(tmpdir, "solution.tex")
            pdf_path = os.path.join(tmpdir, "solution.pdf")

            # Write LaTeX file
            Path(tex_path).write_text(latex_content)

            # Run pdflatex (twice for references)
            try:
                for _ in range(2):
                    result = subprocess.run(
                        ["pdflatex", "-interaction=nonstopmode", "solution.tex"],
                        cwd=tmpdir,
                        capture_output=True,
                        text=True,
                        timeout=30,
                    )

                if not os.path.exists(pdf_path):
                    raise ExportError(
                        "PDF generation failed",
                        technical_details=result.stdout[-1000:]
                        if result.stdout
                        else None,
                        suggestions=["Check LaTeX syntax", "Try LaTeX export instead"],
                    )

                # Copy to output location
                import shutil

                shutil.copy2(pdf_path, output_path)

            except subprocess.TimeoutExpired:
                raise ExportError(
                    "PDF generation timed out",
                    suggestions=["Try again or use LaTeX export"],
                )
            except Exception as e:
                raise ExportError(
                    f"PDF generation failed: {e}",
                    suggestions=["Check that pdflatex is installed correctly"],
                )

        return output_path

    def to_text(self, output_path: Optional[str] = None) -> str:
        """
        Export solution as plain text.

        Args:
            output_path: If provided, write to this file

        Returns:
            The plain text representation
        """
        lines = [
            "=" * 60,
            "MathSolver Solution",
            "=" * 60,
            "",
        ]

        if self.options.include_timestamp:
            lines.append(f"Date: {datetime.now().isoformat()}")
            lines.append("")

        lines.extend(
            [
                "Problem:",
                f"  {self.solution.equation.raw_latex}",
                "",
            ]
        )

        if self.solution.target_variable:
            lines.append(f"Solve for: {self.solution.target_variable}")
            lines.append("")

        if self.options.include_steps and self.solution.steps:
            lines.append("Steps:")
            for step in self.solution.steps:
                lines.append(f"  {step.step_number}. {step.operation}")
                lines.append(f"     {step.latex_repr}")
            lines.append("")

        lines.extend(
            [
                "Result:",
                f"  {self.solution.latex}",
                "",
            ]
        )

        if self.solution.numerical_result is not None:
            lines.append(f"Numerical value: {self.solution.numerical_result}")
            lines.append("")

        if self.options.include_method and self.solution.method_used:
            lines.append(f"Method: {self.solution.method_used}")
            lines.append("")

        lines.append("=" * 60)

        text = "\n".join(lines)

        if output_path:
            Path(output_path).write_text(text)

        return text

    def _latex_escape(self, text: str) -> str:
        """Escape special LaTeX characters in text."""
        replacements = [
            ("\\", r"\textbackslash{}"),
            ("&", r"\&"),
            ("%", r"\%"),
            ("$", r"\$"),
            ("#", r"\#"),
            ("_", r"\_"),
            ("{", r"\{"),
            ("}", r"\}"),
            ("~", r"\textasciitilde{}"),
            ("^", r"\textasciicircum{}"),
        ]
        result = text
        for old, new in replacements:
            result = result.replace(old, new)
        return result

    def _command_available(self, cmd: str) -> bool:
        """Check if a command is available in PATH."""
        try:
            result = subprocess.run(
                ["which", cmd],
                capture_output=True,
                text=True,
            )
            return result.returncode == 0
        except Exception:
            return False


def export_solution_to_clipboard(solution: Solution, format: str = "latex") -> str:
    """
    Generate export content suitable for clipboard.

    Args:
        solution: Solution to export
        format: One of 'latex', 'python', 'text'

    Returns:
        Formatted string for clipboard
    """
    exporter = SolutionExporter(
        solution,
        ExportOptions(
            include_steps=False,
            include_timestamp=False,
            include_method=False,
        ),
    )

    if format == "python":
        return exporter.to_python()
    elif format == "text":
        return exporter.to_text()
    else:  # latex
        # For clipboard, just return the equation, not full document
        return solution.latex
